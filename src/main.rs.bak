
use std::io;
use std::path::Path;
use std::fs::File;
use std::sync::Arc;

use tokio::net::TcpListener;
use tokio::io::{AsyncReadExt, AsyncWriteExt};

use tokio_rustls::rustls::internal::pemfile::{certs, rsa_private_keys};
use tokio_rustls::rustls::{Certificate, NoClientAuth, PrivateKey, ServerConfig, Session};
use tokio_rustls::{TlsAcceptor};

use hyper::server::conn;


fn load_certs(path: &Path) -> std::io::Result<Vec<Certificate>> {
    certs(&mut io::BufReader::new(File::open(path)?))
        .map_err(|_| std::io::Error::new(std::io::ErrorKind::InvalidInput, "invalid cert"))
}

fn load_keys(path: &Path) -> std::io::Result<Vec<PrivateKey>> {
    rsa_private_keys(&mut io::BufReader::new(File::open(path)?))
        .map_err(|_| std::io::Error::new(std::io::ErrorKind::InvalidInput, "invalid key"))
}

async fn process_request(mut req: http::Request<hyper::Body>) -> Result<http::Response<hyper::Body>, hyper::Error> {
    //Ok(http::Response::new(hyper::Body::from("Hyper hello")))
    //Ok(http::Response::new(hyper::Body::from( format!("{:?}", _req))))

    let client = hyper::Client::new();

    //let req = &mut _req;
    //let hdr = _req.headers_mut();

    *req.uri_mut() = "http://httpbin.org/get".parse().unwrap();

    let res = client.request(req).await;

    println!("---------------- Response sent -----------------\n\n\n");

    res
}



#[tokio::main]
pub async fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("starting");

    let certs = load_certs(Path::new("/home/kromgart/certs/httpbin_org.crt")).unwrap();
    let mut pkeys = load_keys(Path::new("/home/kromgart/certs/ca.pem")).unwrap();

    let mut config = ServerConfig::new(NoClientAuth::new());
    config
        .set_single_cert(certs, pkeys.remove(0))
        .map_err(|err| io::Error::new(io::ErrorKind::InvalidInput, err))?;
    let alpn = [Vec::from("http/1.1"), Vec::from("h2") ];
    config.set_protocols(&alpn);

    let tlsacceptor = TlsAcceptor::from(Arc::new(config));


    let tcp_lsn = TcpListener::bind("127.0.0.1:8080").await?;

    loop {
        let (mut socket, _) = tcp_lsn.accept().await?;

        let tlsacceptor = tlsacceptor.clone();

        tokio::spawn(async move {
            let mut buf = [0; 1024];

            loop {
                let n = match socket.read(&mut buf).await {
                    Ok(n) if n == 0 => {
                        println!("Proxy request ends");
                        break;
                    },
                    Ok(n) => n,
                    Err(e) => {
                        println!("failed to read from socket: {:?}", e);
                        return;
                    },
                };

                if n > 0 && n <= 1024 {
                    let rq = std::str::from_utf8(&buf[0..n]);
                    match rq {
                        Ok(rq) => if rq.ends_with("\r\n\r\n") {
                                      println!("PROXYING: {:?}\n\n", rq);
                                      break;
                                  } else {
                                      println!("malformed request: {}\n", rq);
                                      return;
                                  }

                        Err(e) => {
                            panic!("Cannot decode full request ({}). Start: '{:?}'", e, std::str::from_utf8(&buf[0..e.valid_up_to()]).unwrap());
                        }
                    }
                } else {
                    println!("malformed request");
                    return;
                }

            }

            let okstr = "HTTP/1.1 200 OK\r\n\r\n";
            if let Err(e) = socket.write_all(okstr.as_bytes()).await {
                println!("failed to reply 200 OK to socket: {:?}", e);
                return;
            }
            // println!("Sent 200 OK: {}", okstr);




            // ------------------------------  STARTING TUNNEL  ---------------------------------




            let mut tlstream = tlsacceptor.accept(socket).await.unwrap();
            {
                let (_, ses) = tlstream.get_ref();
                println!("TLS ALPN: {:?}", String::from_utf8(ses.get_alpn_protocol().unwrap().to_vec()));
            }
           

            if let Err(http_err) = conn::Http::new()
                .http1_only(true)
                .http1_keep_alive(true)
                .serve_connection(tlstream, hyper::service::service_fn(process_request))
                .await {
                    println!("Error while serving HTTP: {}", http_err);
            }

            /*
            loop {
                let n = match tlstream.read(&mut buf).await {
                    Ok(n) if n == 0 => {
                        println!("Request ends");
                        break;
                    },
                    Ok(n) => n,
                    Err(e) => {
                        println!("failed to read from socket: {:?}", e);
                        return;
                    },
                };

                if n > 0 && n <= 1024 {
                    let rq = std::str::from_utf8(&buf[0..n]).unwrap();
                    println!("TLSing: {:?}\n\n", rq);
                    break;
                } else {
                    println!("malformed request");
                    return;
                }

            }
            
            let resp = b"HTTP/1.0 200 ok\r\n\
                         Connection: close\r\n\
                         Content-length: 12\r\n\
                         \r\n\
                         Hello world!";

            if let Err(e) = tlstream.write_all(&resp[..]).await {
                println!("failed to reply in TLS, {}", e);
                return;
            }

            */


        });
    }

    Ok(())
}
